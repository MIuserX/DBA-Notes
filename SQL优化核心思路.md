# Overview

说到 “优化”，我常常想：为什么要优化？系统运行地好好的，何必要折腾？

在现实中，优化的动力常常来自以下几点：

* **提升用户体验**

* **遇到性能问题**

  在业务量小的时候，设计不怎么良好的系统也能很好地提供服务。但随着业务量的增长，问题就会渐渐出现。

* **降低成本**

  * 机器成本

    通过优化应用程序、架构等，在不牺牲性能地情况下，使用更少更低配置的机器。

  * 维护成本

    提升可维护性，降低维护成本。

  * 人力成本



# SQL 优化思路

下面将要描述的思路适用于几乎所有关系型数据库。

## 系统性优化

关系型数据库的主要功能是：执行 SQL。理想情况下，我们将每种 SQL 都优化到最优形式。那么，数据库执行 SQL 的性能也就达到了最优形式。

假设我们统计了数据库当前执行的 SQL 基本情况，得到类似下面这种形式的统计表：

| SQL   | 执行次数 | 平均执行时间 |
| ----- | -------- | ------------ |
| Sql 1 | 10000    | 1s           |
| Sql 2 | 1000     | 3s           |
| Sql 3 | 10       | 10s          |

我们要找到那些执行次数最到的 SQL，总执行时间最多的 SQL。

因为对这些 SQL 一点点优化，都会因为执行次数的扩大，对数据库总体性能产生巨大的影响。



这种思路是战略性的，只要按照这个思路执行，可以对数据库进行 全面 的优化。



## 局部优化

实际工作生涯中，经常会碰到这种问题：

* X 系统现在好慢，数据库存在什么问题吗？
* Y 接口速度好慢，数据库存在什么问题吗？
* Z SQL 好慢，数据库存在什么问题吗？

上述描述，都犯了同一个错误：没有清晰的定义问题。

我们常说：当清晰的定义一个问题，这个问题就解决了一半。





# PG 的方法

PG 有一个叫做 `pg_stat_activity` 的插件，它可以完成对 SQL 的统计。



# MySQL 的方案



# SQL Server 的方案

